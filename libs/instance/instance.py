import os
import json
import textwrap
import requests
from datetime import datetime
from LauncherBase import Base


class class_instance:
    def __init__(self):
        self.main_class = None
        self.version_type = None
        self.convert_by_legacy = None
        self.support_java_version = None
        self.IsVanilla = None
        self.real_minecraft_version = None
        self.use_legacy_manifest = None
        self.name = None
        self.SelectedInstanceInstalled = None
        self.InstallVersion = False
        self.VersionManifestURl = "https://piston-meta.mojang.com/mc/game/version_manifest_v2.json"
        self.fabric_installer_version_list = "https://meta.fabricmc.net/v2/versions/installer"

        # Instance Info
        self.INSTANCE_NAME = None
        self.CLIENT_VERSION = None
        self.VERSION_TYPE = None
        self.LAUNCHER_VERSION = None
        self.INSTANCE_FORMAT = None
        self.CREATE_DATE = None
        self.CONVERT_FROM_LEGACY = False

        # Instance Structure
        self.game_folder = ".minecraft"
        self.assets_folder = ".minecraft/assets"

        # Modify Info
        self.ISVanilla = False
        self.Modified = False
        self.ModLoaderName = False
        self.ModLoaderVersion = False

        # Config
        self.EnableConfig = True
        self.CFGPath = "instance.bakelh.cfg"

        self.RenameSuccessful = False
        self.instance_path = None

    def create_instance_info(self, instance_name, client_version, version_type, is_vanilla, modify_status,
                             mod_loader_name, mod_loader_version, **kwargs):

        # Setting some path and create date
        selected_instance_dir = os.path.join(Base.launcher_instances_dir, instance_name)
        selected_instance_ini = os.path.join(selected_instance_dir, "instance.bakelh.ini")
        create_date = datetime.now()

        # Check selected_instance_dir status
        if not os.path.exists(selected_instance_dir):
            os.makedirs(selected_instance_dir)
        else:
            self.SelectedInstanceInstalled = True

        # Get kwargs

        # If user using method name "Convert Old Instance Structure" to upgrade instance to new structure, set it to
        # True
        convert_by_legacy = kwargs.get('convert_by_legacy', False)

        # If create instance info version is legacy_version Minecraft,
        use_legacy_manifest = kwargs.get('use_legacy_manifest', False)

        # "REAL" version(a reason for not using client_version to get Minecraft version is Legacy Minecraft instance
        # info client_version is spoof version(check create_instance>version_spoof)
        real_minecraft_version = kwargs.get('real_minecraft_version', client_version)

        # Get java major version
        java_major_version = kwargs.get('java_major_version', None)

        # Main class
        main_class = kwargs.get("main_class", None)

        # Avoid to overwrite old data
        if os.path.exists(selected_instance_ini):
            return True

        instance_info = textwrap.dedent(f"""\
            # BakeLauncher Instance Info
            # This configuration stores instance data for the launcher (e.g., instance_name, client_version).
            # Do NOT edit this file or delete it!

            # Instance Info
            instance_name = "{instance_name}"
            client_version = "{client_version}"
            main_class = "{main_class}"
            support_java_version = "{java_major_version}"
            type = "{version_type}"
            launcher_version = "{Base.launcher_internal_version}"
            instance_format = "{Base.launcher_data_format}"
            create_date = "{create_date}"
            convert_by_legacy = {convert_by_legacy}
            # If your real_minecraft_version is not same as client_version. Maybe you are using a unofficial source Minecraft
            real_minecraft_version = "{real_minecraft_version}"
            use_legacy_manifest = {use_legacy_manifest}

            # Instance Structure
            game_folder = ".minecraft"  # Path to the main game folder
            assets_folder = ".minecraft/assets"  # Path to the assets folder

            # Modify Info
            IsVanilla = {is_vanilla}
            Modified = {modify_status}
            ModLoaderName = {mod_loader_name}
            ModLoaderVersion = {mod_loader_version}

            # Config
            EnableConfig = True
            CFGPath = "instance.bakelh.cfg"
        """)

        with open(selected_instance_ini, "w+") as ini_file:
            ini_file.write(instance_info)

    def get_instance_type(self, minecraft_version):
        response = requests.get(self.VersionManifestURl)
        data = response.json()

        # Search for the specific version
        version_info = next((v for v in data['versions'] if v['id'] == minecraft_version), None)

        # Display the type if found
        if version_info:
            return version_info['type']
        else:
            return None

    @staticmethod
    def create_custom_config(config_file_path, **kwargs):
        overwrite = kwargs.get("overwrite", False)
        default_data = textwrap.dedent("""\
        [BakeLauncher Instance Custom Config]

        ModLoaderClass =
        CustomJVMArgs = 
        MemoryJVMArgs = 
        CustomGameArgs = 
        InjectJARFile = 
        InjectJARPath = 
        ModLoaderGameArgs = 
        ModLoaderJVMArgs = 
        
        """)
        if overwrite:
            if os.path.exists(config_file_path):
                os.remove(config_file_path)
        with open(config_file_path, 'w') as config_file:
            config_file.write(default_data)

    @staticmethod
    def check_custom_config_valid(config_file_path):
        if not os.path.isfile(config_file_path):
            return False
        try:
            with open(config_file_path, 'r') as config_file:
                data = config_file.read()
            return True
        except json.decoder.JSONDecodeError:
            return False

    @staticmethod
    def read_custom_config(config_file_path, item):
        with open(config_file_path, "r") as file:
            lines = file.readlines()

        for line in lines:
            line = line.strip()
            if item in line and '=' in line:
                data = line.split('=', 1)[1].strip()
                return data

        return None

    @staticmethod
    def write_custom_config(custom_config_path, item, data, **kwargs):
        # Define the mapping of items to their corresponding config keys
        item_map = {
            "jvmargs": "CustomJVMArgs",
            "customjvmargs": "CustomJVMArgs",
            "gameargs": "CustomGameArgs",
            "customgameargs": "CustomGameArgs",
            "injectjarpath": "InjectJARPath",
            "modloaderclass": "ModLoaderClass",
            "memoryjvmargs": "MemoryJVMArgs",
            "modloadergameargs": "ModLoaderGameArgs",
            "modloaderjvmargs": "ModLoaderJVMArgs",
        }

        # Normalize item to lowercase and map to config key
        custom_item = item_map.get(item.lower())
        if not custom_item:
            raise ValueError(f"Invalid item: {item}")

        try:
            with open(custom_config_path, 'r') as file:
                lines = file.readlines()

            found = False
            for i in range(len(lines)):
                if custom_item in lines[i]:
                    lines[i] = f'{custom_item} = {data}\n'
                    found = True
                    break

            # If not found and write_new_if_not_found is True, add a new entry
            write_new_if_not_found = kwargs.get('write_new_if_not_found', False)
            if not found and write_new_if_not_found:
                lines.append(f'{custom_item} = {data}\n')

            with open(custom_config_path, 'w') as file:
                file.writelines(lines)

            return found
        except FileNotFoundError:
            raise FileNotFoundError(f"The file {custom_config_path} does not exist.")
        except Exception as e:
            raise RuntimeError(f"An error occurred: {e}")

    @staticmethod
    def write_instance_info(item_name, new_data, instance_info_path):
        if not os.path.exists(instance_info_path):
            return False

        found = False
        try:
            with open(instance_info_path, 'r') as file:
                lines = file.readlines()

            # Look for the item_name in the lines and update its value
            for i in range(len(lines)):
                if item_name in lines[i]:
                    if isinstance(new_data, bool):
                        lines[i] = f'{item_name} = {str(new_data).lower()}\n'
                    else:
                        lines[i] = f'{item_name} = "{new_data}"\n'
                    found = True
                    break  # Exit the loop once we've made the change

            # Write info file
            if found:
                with open(instance_info_path, 'w') as file:
                    file.writelines(lines)

        except (IOError, OSError) as e:  # Handle general file errors
            print(f"Error: {e}")
            return False

        return found

    def get_instance_info(self, instance_info_path, **kwargs):
        """
        Args list:
        instance_info_path: Path to the instance info file.
        info_name: Get selected instance information data(not found return False and None)
        # If info_name is not found return True, {All available data}...
        ignore_not_found: Legacy stuff(don't print instance info file not found error)
        """

        info_name = kwargs.get('info_name', None)
        ignore_not_found = kwargs.get('ignore_not_found')

        #
        if not os.path.exists(instance_info_path):
            return False, None

        try:
            with open(instance_info_path, 'r') as file:
                for line in file:
                    # Strip whitespace and ignore comment lines
                    line = line.strip()
                    if line.startswith("instance_name"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.INSTANCE_NAME = value.strip().strip('"').strip("'")

                    if line.startswith("client_version"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.CLIENT_VERSION = value.strip().strip('"').strip("'")

                    if line.startswith("main_class"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.main_class = value.strip().strip('"').strip("'")

                    if line.startswith("support_java_version"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.support_java_version = value.strip().strip('"').strip("'")

                    if line.startswith("type"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.version_type = value.strip().strip('"').strip("'")

                    if line.startswith("launcher_version"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.LAUNCHER_VERSION = value.strip().strip('"').strip("'")

                    if line.startswith("instance_format"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.INSTANCE_FORMAT = value.strip().strip('"').strip("'")

                    if line.startswith("create_date"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.CREATE_DATE = value.strip().strip('"').strip("'")

                    if line.startswith("convert_by_legacy"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        convert_by_legacy = value.strip().strip('"').strip("'")
                        self.convert_by_legacy = convert_by_legacy.strip("'").strip("'")

                    if line.startswith("real_minecraft_version"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        real_minecraft_version = value.strip().strip('"').strip("'")
                        self.real_minecraft_version = real_minecraft_version.strip("'").strip("'")

                    if line.startswith("use_legacy_manifest"):
                        # Extract the value after the equals sign
                        self.use_legacy_manifest = line.split('=')[1].strip().upper() == "TRUE"

                    if line.startswith("game_folder"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        game_folder = value.strip().strip('"').strip("'")
                        self.game_folder = game_folder.strip("'").strip("'")

                    if line.startswith("assets_folder"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        assets_folder = value.strip().strip('"').strip("'")
                        self.assets_folder = assets_folder.strip("'").strip("'")

                    if line.startswith("IsVanilla"):
                        # Extract the value after the equals sign
                        self.IsVanilla = line.split('=')[1].strip().upper() == "TRUE"

                    if line.startswith("Modified"):
                        # Extract the value after the equals sign
                        self.Modified = line.split('=')[1].strip().upper() == "TRUE"

                    if line.startswith("ModLoaderName"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.ModLoaderName = value.strip().strip('"').strip("'")

                    if line.startswith("ModLoaderVersion"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.ModLoaderVersion = value.strip().strip('"').strip("'")

                    if line.startswith("EnableConfig"):
                        # Extract the value after the equals sign
                        self.EnableConfig = line.split('=')[1].strip().upper() == "TRUE"

                    if line.startswith("CFGPath"):
                        # Extract the value after the equals sign
                        key, value = line.split("=", 1)
                        self.CFGPath = value.strip().strip('"').strip("'")

        except Exception as e:
            return False, f"FailedToReadInstanceInfo>Error: {e}"

        info_list = [self.INSTANCE_NAME, self.CLIENT_VERSION, self.VERSION_TYPE, self.LAUNCHER_VERSION,
                     self.INSTANCE_FORMAT, self.CREATE_DATE]

        if info_name is None:
            return (True, self.INSTANCE_NAME, self.CLIENT_VERSION, self.VERSION_TYPE, self.LAUNCHER_VERSION,
                    self.INSTANCE_FORMAT, self.CREATE_DATE)
        else:
            if info_name == "instance_name":
                return True, self.INSTANCE_NAME
            elif info_name == "client_version":
                return True, self.CLIENT_VERSION
            elif info_name == "main_class":
                return True, self.main_class
            elif info_name == "support_java_version":
                return True, self.support_java_version
            elif info_name == "type":
                return True, self.version_type
            elif info_name == "launcher_version":
                return True, self.LAUNCHER_VERSION
            elif info_name == "instance_format":
                return True, self.INSTANCE_FORMAT
            elif info_name == "create_date":
                return True, self.CREATE_DATE
            elif info_name == "convert_by_legacy":
                return True, self.convert_by_legacy
            elif info_name == "real_minecraft_version":
                return True, self.real_minecraft_version
            elif info_name == "use_legacy_manifest":
                return True, self.use_legacy_manifest
            elif info_name == "game_folder":
                return True, self.game_folder
            elif info_name == "assets_folder":
                return True, self.assets_folder
            elif info_name == "IsVanilla":
                return True, self.IsVanilla
            elif info_name == "Modified":
                return True, self.Modified
            elif info_name == "ModLoaderName":
                return True, self.ModLoaderName
            elif info_name == "ModLoaderVersion":
                return True, self.ModLoaderVersion
            elif info_name == "EnableConfig":
                return True, self.EnableConfig
            elif info_name == "CFGPath":
                return True, self.CFGPath
            else:
                return False, None


instance = class_instance()
