import argparse
import os
import requests
import psutil
import json
from print_color import print
from launch_client import GetGameArgs
from LauncherBase import GetPlatformName
from LauncherBase import ClearOutput
from LauncherBase import timer
from launch_client import launch_wit_args
from Download import get_version_data

def write_config(path, mode, data):
    # Ensure the correct path to the configuration file
    config_file_path = os.path.join(path, 'instance.bakelh.cfg')

    # Check if the config file exists; if not, create it
    if not os.path.exists(config_file_path):
        print("ArgsManager: Can't find config file! Creating...")
        default_data = (
            '[BakeLauncher Instance Config]\n\n<Global>\n# Please DO NOT edit this file!\n\nVersion = '
            'None\nCustomJVMArgs = None\nCustomGameArgs = None\n'
        )
        with open(config_file_path, 'w') as config_file:
            config_file.write(default_data)

    # Load lines from the existing config file
    with open(config_file_path, 'r') as config_file:
        lines = config_file.readlines()

    updated = False  # Flag to track if we've updated the args

    # Update or append based on the mode
    if mode == "WriteGameArgs":
        for i in range(len(lines)):
            if 'CustomGameArgs' in lines[i]:
                # Append the new arguments instead of overwriting
                current_value = lines[i].split('=', 1)[1].strip()  # Get the current value and strip whitespace
                new_value = current_value + ' ' + data  # Append new data
                lines[i] = f'CustomGameArgs = {new_value}\n'
                updated = True
                break  # Exit loop once found

        if not updated:
            # If not updated, append the new data
            lines.append(f'CustomGameArgs = {data}\n')

    elif mode == "WriteJVMArgs":
        for i in range(len(lines)):
            if 'CustomJVMArgs' in lines[i]:
                current_value = lines[i].split('=', 1)[1].strip()  # Get current value and strip whitespace
                new_value = current_value + ' ' + data  # Append new data
                lines[i] = f'CustomJVMArgs = {new_value}\n'
                updated = True
                break  # Exit loop once found

        if not updated:
            # If not updated, append the new data
            lines.append(f'CustomJVMArgs = {data}\n')

    else:
        print("ArgsManager: ? Invalid mode!", color='red')
        return

    # Write the updated lines back to the config file
    with open(config_file_path, 'w') as config_file:
        config_file.writelines(lines)

    print("ArgsManager: Configuration updated successfully!", color='blue')


def get_args(version_id):
    """
    Check if the version data includes the -XstartOnFirstThread argument for macOS.
    """

    version_data = get_version_data(version_id)
    if GetPlatformName.check_platform_valid_and_return() == 'Darwin':
        platform = "osx"
    else:
        platform = GetPlatformName.check_platform_valid_and_return().lower()

    feature_dict = {}  # Dictionary to store features with corresponding arguments
    feature_list = []  # List to store features for user selection

    try:
        # Loop through the game arguments
        for arg in version_data['arguments']['game']:
            if isinstance(arg, dict) and 'rules' in arg:
                for rule in arg['rules']:
                    if 'features' in rule:
                        for feature in rule['features']:
                            if feature not in feature_dict:
                                feature_dict[feature] = []  # Initialize a list for the feature's arguments
                            # Add the corresponding argument values (either string or list)
                            if isinstance(arg['value'], list):
                                feature_dict[feature].extend(arg['value'])
                            else:
                                feature_dict[feature].append(arg['value'])
    except KeyError:
        print("ArgsManager: Your Minecraft version are not support custom game args :(", color='red')
        timer(5)

    # Create a list of features with numbers
    for idx, feature in enumerate(feature_dict.keys(), start=1):
        feature_list.append(f"{idx}: {feature}")

    return feature_list, feature_dict

def get_args_by_feature_choice(user_input, feature_dict):
    try:
        # Convert user input into an index
        index = int(user_input) - 1
        feature_name = list(feature_dict.keys())[index]  # Get the feature name based on the index
        args = feature_dict[feature_name]  # Get the arguments for the selected feature

        # Check if any of the arguments require user input
        for i, arg in enumerate(args):
            if "${" in arg:  # Placeholder indicates it needs user input
                placeholder = arg
                # Ask the user to provide the necessary text for the placeholder
                user_input_text = input(f"Please provide input for {placeholder}: ")
                args[i] = user_input_text  # Replace placeholder with user-provided text

        return args
    except (IndexError, ValueError):
        print("Invalid selection! Please enter a valid number.")
        return None  # Return None to indicate an invalid choice



def get_instances_path():
    try:
        instances_list = os.listdir('instances')
        if len(instances_list) == 0:
            print("ArgsManager: No instances are available to modify :(", color='red')
            print("Try to using DownloadTool to download the Minecraft!", color='yellow')
            timer(4)
            return None, None  # Explicitly return None for both values

        print(instances_list, color='blue')
        print("ArgsManager: Which instance do you want to modify?", color='green')

        try:
            version_id = input(":")
            if version_id in instances_list:
                instances_path = os.path.join("instances", str(version_id))
                return instances_path, version_id
            else:
                print("ArgsManager: Ouch :0 Invalid instance!", color='red')
                timer(4)
                return None, None  # Return None if invalid
        except ValueError:
            print("ArgsManager: Ouch :0 Invalid instance type!", color='red')
            timer(4)
            return None, None  # Return None if exception occurs
    except FileNotFoundError:
        print("ArgsManager: No instances directory found :(", color='red')
        timer(4)
        return None, None  # Return None if directory not found


def modify_game_args():
    path, version_id = get_instances_path()
    if path is None or version_id is None:
        print("ArgsManager: Failed to get instance path or version ID.", color='red')
        return

    username = "${username}"
    access_token = "${access_token}"
    gameDir = "${gameDir}"
    assetsIndex = "${assetsIndex}"
    assets_dir = "${assets_dir}"
    uuid = "${uuid}"

    GameArgs = GetGameArgs(version_id, username, access_token, gameDir, assets_dir, assetsIndex, uuid)
    print("Original Game Args Example:", color='purple')
    print(GameArgs, color='green')

    feature_list, feature_dict = get_args(version_id)

    if feature_dict is None or not feature_dict:
        return

    while True:
        print("You can add these game args:")
        for feature in feature_list:
            print(feature)

        print("You can type 'exit' to go back to the main menu.", color='green')
        user_input = input("Enter the number of the feature you want: ")

        if str(user_input).lower() == "exit":
            timer(2)
            return

        # Get the corresponding arguments for the chosen feature
        args = get_args_by_feature_choice(user_input, feature_dict)

        # Check if args is None (in case of invalid user input)
        if args is not None:
            formatted_args = ' '.join(args)
            print("New args:", formatted_args)
            print("Trying to add custom Game Arguments to config file...", color='green')
            mode = "WriteGameArgs"
            write_config(path, mode, formatted_args)
        else:
            print("ArgsManager: No valid arguments to process :(", color='red')
        ClearOutput(GetPlatformName.check_platform_valid_and_return())


def get_jvm_args(path):
    json_url = 'https://github.com/Techarerm/BakeLauncher-Library/raw/refs/heads/main/JVM/JVM_ramConfigurations.json'
    try:
        # Fetch the JSON data from the URL
        response = requests.get(json_url)

        # Check for a successful response
        response.raise_for_status()  # Raise an error for bad responses

        # Load the JSON data
        jvm_configurations = response.json()

        # Get the total memory size and convert bytes to GB
        memory_info = psutil.virtual_memory()
        total_ram_gb = memory_info.total / (1024 ** 3)

        # Only print the integer value if the decimal part is greater than 0.5
        int_total_ram = int(total_ram_gb) + (1 if (total_ram_gb % 1) > 0.5 else 0)

        # Determine the matching configuration based on the total RAM
        if int_total_ram <= 4:
            selected_ram = '4GB'
        elif int_total_ram <= 8:
            selected_ram = '8GB'
        elif int_total_ram <= 16:
            selected_ram = '16GB'
        elif int_total_ram <= 32:
            selected_ram = '32GB'
        else:
            selected_ram = '32GB'  # Default to 32GB for larger systems

        # Get the corresponding JVM arguments
        jvm_args = jvm_configurations["ramConfigurations"].get(selected_ram)

        if jvm_args:
            print(f"Selected RAM Configuration: {selected_ram}", color='blue')
            print(f"Maximum Memory (Xmx): {jvm_args['Xmx']}" , color='green')
            print(f"Initial Memory (Xms): {jvm_args['Xms']}" , color='red')
            full_args = ""
            for arg in jvm_args['JVMArgs']:
                full_args += arg + " "
            print(f"Full JVM Arguments: {full_args}]")
            write_config(path, "WriteJVMArgs", full_args)
            timer(5)
        else:
            print(f"No JVM arguments found for {selected_ram} configuration.")

    except requests.exceptions.RequestException as e:
        print(f"An error occurred while fetching the JSON data: {e}")
    except json.JSONDecodeError as e:
        print(f"JSON decoding error: {e}")


def modify_jvm_args():
    path, version_id = get_instances_path()
    if path is None or version_id is None:
        print("ArgsManager: Failed to get instance path or version ID.", color='red')
        return
    print("1:Edit Minecraft Usage RAM Size", color='green')
    print("2: Custom Args(need input)")
    print("3: Generate Args adapted to your computer")
    user_input = int(input(":"))
    if user_input == 1:
        print("test")
    elif user_input == 2:
        print("test")
    elif user_input == 3:
        get_jvm_args(path)


def argsman():
    ClearOutput(GetPlatformName.check_platform_valid_and_return())
    print("Modify Launch arguments are coming soon :)", color='g')
    print("[ArgsManager]")
    print("1: Modify Game Args 2: Modify JVM Args")

    try:
        user_input = int(input(":"))
        if user_input == 1:
            modify_game_args()
        elif user_input == 2:
            modify_jvm_args()
        else:
            print("ArgsManager: Unknown option :0", color='red')
            argsman()
    except ValueError:
        print("ArgsManager: Unknown type :0", color='red')
        argsman()

def parse_arguments(platform, custom_args):
    version = librariesCFG = gameDir = assetsDir = assetsIndex = JVMPath = nativespath = MainClass =None
    # Create ArgumentParser for handling custom arguments
    parser = argparse.ArgumentParser(description='"BakeLauncher Custom Arguments Manager"')

    # Add the '-launch' argument (mandatory)
    parser.add_argument('-launch', help="Enable automatic launch client.")

    # Add the optional arguments (they will be required only if -launch is provided)
    parser.add_argument('--version', dest="version", type=str, help="Launch Minecraft version.")
    parser.add_argument('--librariesCFG', dest="librariesCFG", type=str, help="Libraries cfg")
    parser.add_argument('--gameDir', dest="gameDir", type=str, help=".minecraft folder path")
    parser.add_argument('--assetsDir', dest="assetsDir", type=str, help="Assets folder path")
    parser.add_argument('--assetsIndex', dest="assetsIndex", type=str, help="Assets folder path")
    parser.add_argument('--JVMPath', dest="JVMPath", type=str, help="Java runtimes path")
    parser.add_argument('--nativesPath', dest="nativesPath", type=str, help="natives path")
    parser.add_argument('--MainClass', dest="MainClass", type=str, help="MainClass")

    # Parse the initial arguments to check if '-launch' is provided
    args = parser.parse_args(custom_args)

    # If '-launch' is provided, enforce that the other arguments are mandatory
    if args.launch:
        # Ensure that all other arguments are provided
        if not args.version:
            parser.error("--version is required when using -launch")
        if not args.librariesCFG:
            parser.error("--librariesCFG is required when using -launch")
        if not args.gameDir:
            parser.error("--gameDir is required when using -launch")
        if not args.assetsDir:
            parser.error("--assetsDir is required when using -launch")
        if not args.assetsIndex:
            parser.error("--assetsIndex is required when using -launch")
        if not args.nativesPath:
            parser.error("--assetsIndex is required when using -launch")
        if not args.MainClass:
            parser.error("--MainClass is required when using -launch")

    # Assign parsed argument values to variables
    version = args.version
    librariesCFG = args.librariesCFG
    gameDir = args.gameDir
    assetsDir = args.assetsDir
    assetsIndex = args.assetsIndex
    JVMPath = args.JVMPath
    nativespath = args.nativesPath
    MainClass = args.MainClass

    # Return the parsed arguments
    ErrorCheck_Launch = launch_wit_args(platform, version, librariesCFG, gameDir, assetsDir, assetsIndex, JVMPath, nativespath, MainClass)
    if ErrorCheck_Launch == None:
        return
    else:
        print(f"BakeLauncher: Custom arguments launch failed! Cause By {ErrorCheck_Launch}")
    return True